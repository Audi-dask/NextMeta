# 数据脱敏实现与安全机制详解

## 1. 背景与挑战

在 SQL 审计平台中，数据脱敏是核心安全功能之一。最初的实现方案是基于 **结果集列名匹配**：
1. 执行 SQL 查询。
2. 获取结果集的列名（Column Names）。
3. 将列名与脱敏规则（如 `user_account_id`）进行正则匹配。
4. 如果匹配，对该列数据进行脱敏处理。

### 1.1 安全漏洞：别名与函数绕过

这种基于结果集的方案存在明显的安全漏洞。用户可以通过 SQL 别名或函数运算改变结果集的列名，从而绕过脱敏规则。

**绕过示例 1：别名绕过**
```sql
SELECT user_account_id AS uid FROM orders;
```
*   结果集列名为 `uid`。
*   脱敏规则配置为 `user_account_id`。
*   **结果：** 规则未命中，敏感数据明文泄露。

**绕过示例 2：函数嵌套绕过**
```sql
SELECT concat(user_account_id, '') FROM orders;
```
*   结果集列名可能为 `concat(user_account_id, '')`（取决于数据库驱动）。
*   如果规则仅匹配纯字段名，则可能绕过。

**绕过示例 3：嵌套子查询绕过（高危）**
```sql
SELECT t.uid FROM (SELECT user_account_id AS uid FROM orders) t;
```
*   内层查询将敏感字段重命名为 `uid`。
*   外层查询直接选择 `uid`。
*   后端仅看到最终结果列 `uid`，无法感知其源头是 `user_account_id`。

## 2. 解决方案：基于 AST 的血缘分析 (Lineage Analysis)

为了彻底解决上述问题，我们引入了 **SQL 语义分析**，从“看结果”转向“看源头”。我们使用 `vitess` SQL 解析器对用户提交的 SQL 进行深度解析，追踪数据的来源。

### 2.1 核心逻辑

在 SQL 执行 **之前**，后端会对 SQL 进行以下处理：

1.  **解析 (Parse)**: 将 SQL 文本解析为抽象语法树 (AST)。
2.  **血缘追踪 (Lineage Tracking)**:
    *   递归遍历 AST。
    *   分析 `FROM` 子句，识别子查询（Derived Tables）。
    *   在子查询中查找敏感字段，并记录其输出别名（Tainted Aliases）。
    *   将“污染”状态向上传递到外层查询。
3.  **标记 (Tagging)**:
    *   分析最外层的 `SELECT` 投影列。
    *   如果某列引用了敏感字段（直接引用或通过被污染的别名引用），记录其在结果集中的 **索引位置 (Index)**。
4.  **强制脱敏 (Enforcement)**:
    *   SQL 执行后，遍历结果集。
    *   **优先** 根据记录的 **索引位置** 进行脱敏，忽略结果集的实际列名。
    *   作为兜底，如果索引未命中，再尝试基于列名的匹配（兼容 `SELECT *` 等简单场景）。

### 2.2 代码实现细节

核心逻辑位于 `backend/internal/service/datasource_service.go` 中的 `analyzeLineage` 和 `analyzeSubquery` 方法。

#### 递归分析流程

```go
func (s *dataSourceService) analyzeLineage(stmt *sqlparser.Select, rules []model.DataSourceMaskingRule) map[int]model.DataSourceMaskingRule {
    // 1. 分析 FROM 子句，寻找子查询产生的“污染别名”
    taintedAliases := make(map[string]model.DataSourceMaskingRule)
    for _, tableExpr := range stmt.From {
        // 递归调用 analyzeSubquery
        // 如果子查询 SELECT user_account_id AS uid
        // 则 taintedAliases["uid"] = Rule{user_account_id}
    }

    // 2. 分析主查询的 SELECT 列表
    maskingMap := make(map[int]model.DataSourceMaskingRule)
    for i, expr := range stmt.SelectExprs {
        // 遍历表达式树 (sqlparser.Walk)
        // 检查是否引用了：
        // a. 原始敏感字段 (如 user_account_id)
        // b. 污染别名 (如 uid)
        
        if found {
            maskingMap[i] = matchedRule // 记录：第 i 列需要脱敏
        }
    }
    return maskingMap
}
```

## 3. 验证与效果

经过验证，该方案能有效防御多种绕过手段。

**测试 SQL:**
```sql
SELECT t.uid 
FROM (
    SELECT user_account_id AS uid 
    FROM `mexico_microloan`.`orders` 
    LIMIT 20
) t
```

**处理过程:**
1.  **内层分析**: 识别出 `user_account_id` 映射为别名 `uid` -> 标记 `uid` 为敏感源。
2.  **外层分析**: 识别出 `t.uid` 引用了敏感源 `uid`。
3.  **结果标记**: 标记结果集第 0 列需要脱敏。
4.  **最终输出**: 尽管列名为 `uid`，数据依然被正确脱敏（如 `105******229`）。

## 4. 局限性与未来规划

*   **复杂 SQL 支持**: 目前主要支持 `SELECT` 语句的别名和子查询追踪。对于极其复杂的存储过程或动态 SQL，静态分析可能受限。
*   **性能开销**: AST 解析和遍历会增加微小的 CPU 开销，但在通常的 SQL 查询延迟面前可忽略不计。
*   **通配符处理**: 对于 `SELECT *`，由于无法在不查询 schema 的情况下确定列序，目前仍回退到基于列名的匹配机制。建议生产环境尽量明确指定列名。



```sql 测试素材
-- 数据库审核平台脱敏规则测试集
-- 目标表: mexico_microloan.orders
-- 敏感字段: user_account_id
-- 测试目的: 验证审核逻辑是否能识别经过变形、别名或函数包裹后的敏感字段引用

USE `mexico_microloan`;

-- ==========================================
-- 1. 基础对照组 (Base Cases)
-- ==========================================
-- 直接查询，最基础的拦截目标
SELECT user_account_id FROM orders LIMIT 1;
SELECT `user_account_id` FROM `orders` LIMIT 1;
SELECT orders.user_account_id FROM orders LIMIT 1;

-- ==========================================
-- 2. 函数包裹与类型转换 (Function Wrapping)
-- 测试点: 规则是否只检测字段名，忽略了函数内部
-- ==========================================
-- 哈希与编码
SELECT MD5(user_account_id) FROM orders LIMIT 1;
SELECT HEX(user_account_id) FROM orders LIMIT 1;
SELECT TO_BASE64(user_account_id) FROM orders LIMIT 1;

-- 字符串操作
SELECT CONCAT(user_account_id, '_test') FROM orders LIMIT 1;
SELECT CONCAT_WS('-', user_account_id, 'prefix') FROM orders LIMIT 1;
SELECT SUBSTR(user_account_id, 1, 5) FROM orders LIMIT 1;
SELECT LEFT(user_account_id, 5) FROM orders LIMIT 1;
SELECT TRIM(user_account_id) FROM orders LIMIT 1;
SELECT REVERSE(user_account_id) FROM orders LIMIT 1;

-- 类型转换 (Cast/Convert)
SELECT CAST(user_account_id AS CHAR) FROM orders LIMIT 1;
SELECT CONVERT(user_account_id, CHAR) FROM orders LIMIT 1;

-- 聚合函数 (容易导致批量泄露)
SELECT GROUP_CONCAT(user_account_id) FROM orders LIMIT 1;
SELECT MAX(user_account_id) FROM orders; -- 如果是ID类通常不敏感，但逻辑上依然是引用

-- ==========================================
-- 3. 逻辑运算与表达式 (Operations)
-- 测试点: 利用表达式改变字段的字面形态
-- ==========================================
-- 逻辑判断 (CASE WHEN / IF)
SELECT CASE WHEN 1=1 THEN user_account_id ELSE '0' END FROM orders LIMIT 1;
SELECT IF(TRUE, user_account_id, 'hidden') FROM orders LIMIT 1;
SELECT COALESCE(NULL, user_account_id) FROM orders LIMIT 1;

-- 隐式运算 (假设 ID 是数字或可转换)
SELECT user_account_id + 0 FROM orders LIMIT 1;
SELECT user_account_id * 1 FROM orders LIMIT 1;

-- ==========================================
-- 4. 别名与子查询 (Aliasing & Subqueries)
-- 测试点: 最核心的测试，验证是否具备“列血缘(Lineage)”分析能力
-- ==========================================
-- 简单别名 (如果在 SELECT 解析阶段没还原别名，极易绕过)
SELECT user_account_id AS harmless_id FROM orders LIMIT 1;
SELECT user_account_id "uid" FROM orders LIMIT 1;

-- 子查询包裹 (外层查询看起来完全无害)
SELECT t.safe_col FROM (SELECT user_account_id AS safe_col FROM orders) t LIMIT 1;

-- 多层嵌套
SELECT final_col FROM (SELECT temp_col AS final_col FROM (SELECT user_account_id AS temp_col FROM orders) a) b LIMIT 1;

-- CTE (公用表表达式) - MySQL 8.0+
WITH sensitive_data AS (
    SELECT user_account_id FROM orders
)
SELECT * FROM sensitive_data LIMIT 1;

-- ==========================================
-- 5. 语法混淆 (Syntax Obfuscation)
-- 测试点: 干扰正则表达式匹配
-- ==========================================
-- 内联注释干扰 (注释可能打断正则关键词匹配)
SELECT user_account_id/**/ FROM orders LIMIT 1;
SELECT user_account_id /*!50000 */ FROM orders LIMIT 1;

-- 换行与空白符干扰
SELECT 
    user_account_id 
FROM 
    orders 
LIMIT 1;

-- 表别名通配符 (虽然没写字段名，但查出了所有数据)
SELECT t.* FROM orders t LIMIT 1;
```